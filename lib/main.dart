/*
    From Alex: the main source file template is generated by Android Studio.

    A lot of assistance was taken from
      https://api.flutter.dev/flutter

*/

import 'package:flutter/material.dart';
import 'package:json_annotation/json_annotation.dart';
import 'package:http/http.dart' as http;
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:path_provider/path_provider.dart' as path;
import 'fav.dart' as fav_page;

void main() {
  runApp(const ChuckApp());
}

/* App itself is immutable widget - got it */
class ChuckApp extends StatelessWidget {
  const ChuckApp({super.key});

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Tinder Chuck!',
      theme: ThemeData(primarySwatch: Colors.grey),
      home: const ClickerPage(title: 'Tinder Chuck! Now on Flutter.'),
    );
  }
}

/* Home page, as an app's child, should have the state etc. - also got it */
class ClickerPage extends StatefulWidget {
  const ClickerPage({super.key, required this.title});

  // This widget is the home page of your application. It is stateful, meaning
  // that it has a State object (defined below) that contains fields that affect
  // how it looks.

  // This class is the configuration for the state. It holds the values (in this
  // case the title) provided by the parent (in this case the App widget) and
  // used by the build method of the State. Fields in a Widget subclass are
  // always marked "final".

  final String title;

  @override
  State<ClickerPage> createState() => _ClickerPageState();
}

class _ClickerPageState extends State<ClickerPage> {
  // Logic ------------------------------------------------------------
  // URLs.
  final String funUrl = 'https://api.chucknorris.io/jokes/random';
  final String catUrl = 'https://api.chucknorris.io/jokes/categories';
  // In clear Android, I'd put these lines to R.
  final String swpTxt = 'Swipe!';
  final String errMsg = 'Chucknorris.io did not send the nudes.';
  final String chkTxt = 'Star!';
  final String defTxt = '(*) (*)';
  final String jmpTxt = 'Check starred';
  // These 3 variables are expected to be in AppContext
  final String filepath = 'favorites.txt';
  late String currentJoke;
  late String currentValue = '';

  late Future<Joke> futureJoke;
  late Future<List<String>> futureCategories;
  List<String>? categories;

  // Calls for new joke
  Future<Joke> getJoke(String? category) async {
    String query = funUrl;
    if (category != null) {
      query += '?category=$category';
    }
    final http.Response response = await http.get(Uri.parse(query));
    if (response.statusCode == 200) {
      return Joke.fromJson(jsonDecode(response.body));
    } else {
      throw Exception(errMsg);
    }
  }

  // Calls once per Activity
  Future<List<String>> getCategories() async {
    final http.Response catResponse = await http.get(Uri.parse(catUrl));
    if (catResponse.statusCode == 200) {
      Iterable<Object?> l = json.decode(catResponse.body);
      debugPrint('Response itself: $l');
      List<String> bufCategories =
          List<String>.from(l.map((Object? model) => (model as String)));
      categories = bufCategories.toList();
      return bufCategories;
    } else {
      throw Exception(errMsg);
    }
  }

  @override
  void initState() {
    super.initState();
    // Get 1st joke
    futureJoke = getJoke(null);
    // Get list of categories
    futureCategories = getCategories();
  }

  // Call for new joke
  void standUp(String? category) {
    setState(() {
      futureJoke = getJoke(category);
      if (category != null) {
        currentValue = category;
      } else {
        currentValue = categories!.first;
      }
    });
  }

  // Save marked value
  Future<void> addFavorite(String line) async {
    final Directory directory = await path.getApplicationDocumentsDirectory();
    File file = File('${directory.path}/$filepath');
    file.writeAsString('$line\n',
        mode: FileMode.append, encoding: utf8, flush: true);
  }

  // UI ------------------------------------------------------------
  /* Be advised, I'm not a good designer.
	*
	*   App top bar
	* 	TextBox for current joke
	* 	Random joke
	*   DropdownButton (for clickable categories)
	* 	Mark [append to favorites]
	* 	Button as switcher
	*/
  @override
  Widget build(BuildContext context) {
    // This method is rerun every time setState is called
    return SafeArea(
        top: true,
        child: Scaffold(
          appBar: AppBar(title: Text(widget.title)),
          // Body of page
          body: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Center(
                child: Column(
                  children: <Widget>[
                    Text(
                      defTxt,
                      style: Theme.of(context).textTheme.headlineMedium,
                    ),
                    FutureBuilder<Joke>(
                        future: futureJoke,
                        builder: (BuildContext context,
                            AsyncSnapshot<Joke> snapshot) {
                          if (snapshot.hasData) {
                            currentJoke = snapshot.data!.value;
                            return Text(snapshot.data!.value);
                          } else if (snapshot.hasError) {
                            return Text('${snapshot.error}');
                          }
                          return Text(errMsg);
                        }),
                    TextButton(
                        onPressed: () => standUp(null),
                        style: TextButton.styleFrom(
                            backgroundColor: Colors.lime,
                            foregroundColor: Colors.black87),
                        child: Text(swpTxt)),
                    DropdownButton(
                      value: currentValue,
                      items: categories
                          ?.map<DropdownMenuItem<String>>((String value) {
                        return DropdownMenuItem<String>(
                          value: value,
                          child: Text(value),
                        );
                      }).toList(),
                      onChanged: (String? value) => standUp(value as String),
                    ),
                    TextButton(
                      onPressed: () => addFavorite(currentJoke),
                      style: TextButton.styleFrom(
                          backgroundColor: Colors.redAccent,
                          foregroundColor: Colors.yellowAccent),
                      child: Text(chkTxt),
                    ),
                    TextButton(
                        style: TextButton.styleFrom(
                            backgroundColor: Colors.greenAccent,
                            foregroundColor: Colors.yellowAccent),
                        onPressed: () {
                          Navigator.push(
                              context,
                              MaterialPageRoute(
                                  builder: (BuildContext context) =>
                                      fav_page.FavoritesPage(
                                          title: widget.title)));
                        },
                        child: Text(jmpTxt))
                  ],
                ),
              )),
        ));
  }
}

// We know the format from URL
@JsonSerializable()
class Joke {
  @JsonKey(name: 'icon_url')
  final String iconUrl;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'updated_at')
  final String updatedAt;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'value')
  final String value;

  // Java-like constructors. Deja-vu.
  Joke(this.iconUrl, this.id, this.createdAt, this.updatedAt, this.url,
      this.value);

  // We need parsing only.
  // https://docs.flutter.dev/development/data-and-backend/json
  // factory Joke.fromJson(Map<String, dynamic> json) => _$JokeFromJson(json);
  // Ok, direct parsing only since runtime compilation did not solve the highlighted error.
  Joke.fromJson(Map<String, dynamic> json)
      : iconUrl = json['icon_url'],
        id = json['id'],
        createdAt = json['created_at'],
        updatedAt = json['updated_at'],
        url = json['url'],
        value = json['value'];
}
